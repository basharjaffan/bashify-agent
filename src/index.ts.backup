import { spawn } from 'child_process';
import mqtt from 'mqtt';
import { logger } from './logger.js';
import { initializeFirebase, getFirestore } from './config/firebase.js';
import { getDeviceId, getGroupStreamUrl, updateDeviceHeartbeat } from './config/loader.js';

const DEFAULT_STREAM = 'https://ice1.somafm.com/groovesalad-256-mp3';
const MQTT_URL = process.env.MQTT_URL || 'mqtt://localhost:1883';
const ORGANIZATION_ID = 'LdpwUPcwIFUZjIwYph8Z';

let playerProcess: any = null;
let currentUrl: string = DEFAULT_STREAM;
let deviceId: string;
let mqttClient: mqtt.MqttClient;
let firestore: any;

function playStream(url: string) {
  if (playerProcess) {
    try { playerProcess.kill(); } catch (e) {}
  }

  currentUrl = url;
  logger.info({ url }, 'ğŸµ Starting music...');

  playerProcess = spawn('mpv', [
    '--no-video',
    '--audio-device=alsa',
    '--really-quiet',
    url
  ]);

  playerProcess.on('error', (error: Error) => {
    logger.error({ error }, 'âŒ Failed to start player');
  });

  playerProcess.on('spawn', () => {
    logger.info('âœ… Music started successfully!');
    setTimeout(() => {
      publishStatus();
      updateFirestoreStatus();
    }, 100);
  });

  playerProcess.on('exit', (code: number) => {
    logger.warn({ code }, 'â¹ï¸ Player stopped');
    playerProcess = null;
    setTimeout(() => {
      publishStatus();
      updateFirestoreStatus();
    }, 100);
  });
}

function publishStatus() {
  if (!mqttClient || !mqttClient.connected) {
    return;
  }

  try {
    const status = {
      device_id: deviceId,
      playing: playerProcess !== null,
      current_url: currentUrl,
      timestamp: new Date().toISOString()
    };

    const topic = `radio-revive/${ORGANIZATION_ID}/device/${deviceId}/status`;
    mqttClient.publish(topic, JSON.stringify(status), { qos: 0, retain: false });
  } catch (error) {
    logger.error({ error }, 'Error in publishStatus');
  }
}

async function updateFirestoreStatus() {
  try {
    const isPlaying = playerProcess !== null;
    await updateDeviceHeartbeat(firestore, deviceId, isPlaying, currentUrl);
  } catch (error) {
    logger.error({ error }, 'Failed to update Firestore status');
  }
}

// New function to listen for Firebase commands
function listenForCommands() {
  try {
    const commandsRef = firestore
      .collection('config')
      .doc('devices')
      .collection('list')
      .doc(deviceId)
      .collection('commands');

    commandsRef
      .where('processed', '==', false)
      .onSnapshot((snapshot: any) => {
        snapshot.docChanges().forEach(async (change: any) => {
          if (change.type === 'added') {
            const commandData = change.doc.data();
            const commandId = change.doc.id;
            
            logger.info({ commandData }, 'ğŸ“¨ Received Firebase command');

            try {
              if (commandData.action === 'play' && commandData.url) {
                playStream(commandData.url);
              } else if (commandData.action === 'stop') {
                if (playerProcess) {
                  playerProcess.kill();
                  playerProcess = null;
                  setTimeout(() => {
                    publishStatus();
                    updateFirestoreStatus();
                  }, 100);
                }
              } else if (commandData.action === 'pause') {
                if (playerProcess) {
                  playerProcess.kill();
                  playerProcess = null;
                  setTimeout(() => {
                    publishStatus();
                    updateFirestoreStatus();
                  }, 100);
                }
              }

              // Mark command as processed
              await commandsRef.doc(commandId).update({ processed: true });
              logger.info({ commandId }, 'âœ… Command processed');
            } catch (error) {
              logger.error({ error, commandId }, 'Failed to process command');
            }
          }
        });
      }, (error: any) => {
        logger.error({ error }, 'Error listening for commands');
      });

    logger.info('ğŸ‘‚ Listening for Firebase commands...');
  } catch (error) {
    logger.error({ error }, 'Failed to set up command listener');
  }
}

// New function to listen for device document changes (group assignment)
function listenForDeviceChanges() {
  try {
    const deviceRef = firestore
      .collection('config')
      .doc('devices')
      .collection('list')
      .doc(deviceId);

    deviceRef.onSnapshot(async (snapshot: any) => {
      if (snapshot.exists) {
        const deviceData = snapshot.data();
        
        // Check if streamUrl changed
        if (deviceData.streamUrl && deviceData.streamUrl !== currentUrl) {
          logger.info({ 
            oldUrl: currentUrl, 
            newUrl: deviceData.streamUrl 
          }, 'ğŸ”„ Stream URL changed, updating playback');
          
          playStream(deviceData.streamUrl);
        }
      }
    }, (error: any) => {
      logger.error({ error }, 'Error listening for device changes');
    });

    logger.info('ğŸ‘‚ Listening for device changes...');
  } catch (error) {
    logger.error({ error }, 'Failed to set up device listener');
  }
}

async function bootstrap() {
  try {
    logger.info('ğŸš€ Radio Revive Agent starting...');

    await initializeFirebase();
    firestore = getFirestore();

    deviceId = await getDeviceId();
    logger.info({ deviceId }, 'ğŸ“± Device ID generated');

    await updateFirestoreStatus();

    // Start listening for commands and device changes
    listenForCommands();
    listenForDeviceChanges();

    const uniqueClientId = `radio-revive-${deviceId}-${Date.now()}`;
    
    mqttClient = mqtt.connect(MQTT_URL, {
      clientId: uniqueClientId,
      clean: true,
      keepalive: 60,
      connectTimeout: 30000,
      reconnectPeriod: 0
    });

    mqttClient.on('connect', () => {
      logger.info({ clientId: uniqueClientId }, 'âœ… MQTT connected');
      
      const controlTopic = `radio-revive/${ORGANIZATION_ID}/device/${deviceId}/control`;
      mqttClient.subscribe(controlTopic, { qos: 1 }, (err) => {
        if (err) {
          logger.error({ err }, 'Failed to subscribe to control topic');
        } else {
          logger.info({ topic: controlTopic }, 'ğŸ“¡ Subscribed to control topic');
        }
      });

      setTimeout(() => publishStatus(), 100);
    });

    mqttClient.on('message', (topic: string, message: Buffer) => {
      try {
        const payload = JSON.parse(message.toString());
        logger.info({ topic, payload }, 'ğŸ“¨ Received MQTT message');

        if (payload.command === 'play' && payload.url) {
          playStream(payload.url);
        } else if (payload.command === 'stop') {
          if (playerProcess) {
            playerProcess.kill();
            playerProcess = null;
            setTimeout(() => {
              publishStatus();
              updateFirestoreStatus();
            }, 100);
          }
        } else if (payload.command === 'restart') {
          playStream(currentUrl);
        }
      } catch (error) {
        logger.error({ error }, 'Failed to parse MQTT message');
      }
    });

    mqttClient.on('error', (error: Error) => {
      logger.error({ error }, 'MQTT error');
    });

    mqttClient.on('close', () => {
      logger.warn('MQTT connection closed - attempting manual reconnect');
      setTimeout(() => {
        if (!mqttClient.connected) {
          logger.info('Manual reconnect attempt');
          mqttClient.reconnect();
        }
      }, 5000);
    });

    mqttClient.on('offline', () => {
      logger.warn('MQTT client offline');
    });

    logger.info('ğŸ” Looking for group stream URL...');
    const streamUrl = await getGroupStreamUrl(firestore, deviceId);
    
    if (streamUrl) {
      playStream(streamUrl);
    } else {
      logger.info('No group stream found, using default stream as fallback');
      playStream(DEFAULT_STREAM);
    }

    setInterval(() => {
      publishStatus();
      updateFirestoreStatus();
    }, 20000);

  } catch (error) {
    logger.error({ error }, 'âŒ Failed to start agent');
    process.exit(1);
  }
}

bootstrap();
