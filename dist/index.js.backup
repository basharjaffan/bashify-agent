import { initializeApp, cert } from 'firebase-admin/app';
import { getFirestore } from 'firebase-admin/firestore';
import { exec } from 'child_process';
import { promisify } from 'util';
import { readFileSync, writeFileSync, existsSync, unlinkSync } from 'fs';
import { logger } from './logger.js';
import { getDeviceId, updateDeviceHeartbeat } from './config/loader.js';

const execAsync = promisify(exec);

const MPV_LOCK = '/tmp/bashify-mpv.lock';
const AGENT_LOCK = '/tmp/bashify-agent.lock';

if (existsSync(AGENT_LOCK)) {
    const pid = readFileSync(AGENT_LOCK, 'utf8').trim();
    try {
        process.kill(parseInt(pid), 0);
        logger.error({ existingPid: pid }, 'âŒ Another agent is already running! Exiting.');
        process.exit(1);
    } catch {
        logger.warn('Stale agent lock found, cleaning up');
        unlinkSync(AGENT_LOCK);
    }
}

writeFileSync(AGENT_LOCK, String(process.pid));

process.on('exit', () => {
    try { unlinkSync(AGENT_LOCK); } catch {}
    try { unlinkSync(MPV_LOCK); } catch {}
});

const serviceAccount = JSON.parse(
    readFileSync('/home/dietpi/radio-revive/rpi-agent/service-account.json', 'utf8')
);

initializeApp({ credential: cert(serviceAccount) });
const firestore = getFirestore();
const DEVICE_ID = getDeviceId();

logger.info({ deviceId: DEVICE_ID, pid: process.pid }, 'ðŸš€ Agent starting (SINGLETON MODE)');

let currentStreamUrl = null;
let isPlaying = false;
let isPaused = false;
let currentVolume = 100;
let isPlayLocked = false;

async function play(streamUrl) {
    if (isPlayLocked) {
        logger.warn('âš ï¸ Play locked, ignoring duplicate call');
        return;
    }

    try {
        isPlayLocked = true;
        
        logger.info('ðŸ”ª Killing all MPV processes...');
        await execAsync('pkill -9 mpv').catch(() => {});
        await new Promise(r => setTimeout(r, 1500));
        
        const { stdout: check1 } = await execAsync('pgrep mpv || echo 0').catch(() => ({ stdout: '0' }));
        if (check1.trim() !== '0') {
            logger.error('âŒ MPV still alive after kill, aborting');
            isPlayLocked = false;
            return;
        }
        
        if (existsSync(MPV_LOCK)) {
            const lockPid = readFileSync(MPV_LOCK, 'utf8').trim();
            logger.warn({ lockPid }, 'Found MPV lock, killing process');
            await execAsync(`kill -9 ${lockPid}`).catch(() => {});
            unlinkSync(MPV_LOCK);
        }
        
        const urlToPlay = streamUrl || currentStreamUrl;
        if (!urlToPlay) {
            logger.warn('No URL to play');
            isPlayLocked = false;
            return;
        }
        
        currentStreamUrl = urlToPlay;
        
        const minVol = -10239;
        const maxVol = 400;
        const volumeRaw = Math.round(minVol + (currentVolume / 100) * (maxVol - minVol));
        await execAsync(`amixer set PCM -- ${volumeRaw}`);
        
        logger.info({ url: urlToPlay }, 'â–¶ï¸ Starting MPV...');
        const mpvCmd = `nohup mpv --no-video --audio-device=alsa --really-quiet --input-ipc-server=/tmp/mpv-socket "${urlToPlay}" >/dev/null 2>&1 & echo $!`;
        const { stdout: pidOutput } = await execAsync(mpvCmd);
        const mpvPid = pidOutput.trim();
        
        writeFileSync(MPV_LOCK, mpvPid);
        logger.info({ mpvPid }, 'âœ… MPV started with PID');
        
        await new Promise(r => setTimeout(r, 2000));
        const { stdout: countCheck } = await execAsync('pgrep mpv | wc -l');
        const mpvCount = parseInt(countCheck.trim());
        
        if (mpvCount === 0) {
            logger.error('âŒ MPV failed to start');
            isPlayLocked = false;
            return;
        }
        
        if (mpvCount > 1) {
            logger.error({ count: mpvCount }, 'ðŸš¨ MULTIPLE MPV DETECTED! Killing all...');
            await execAsync('pkill -9 mpv');
            unlinkSync(MPV_LOCK);
            isPlayLocked = false;
            return;
        }
        
        isPlaying = true;
        isPaused = false;
        
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ 
                status: 'playing', 
                isPlaying: true, 
                currentUrl: urlToPlay 
            });
        
        await updateDeviceHeartbeat(firestore, DEVICE_ID, true, urlToPlay);
        
        logger.info({ mpvCount }, 'âœ… Play successful');
        
    } catch (error) {
        logger.error({ error: String(error) }, 'âŒ Play failed');
    } finally {
        isPlayLocked = false;
    }
}

async function stop() {
    try {
        logger.info('â¹ï¸ Stopping music...');
        await execAsync('pkill -9 mpv').catch(() => {});
        await new Promise(r => setTimeout(r, 1000));
        
        if (existsSync(MPV_LOCK)) unlinkSync(MPV_LOCK);
        
        isPlaying = false;
        isPaused = false;
        currentStreamUrl = '';
        
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ 
                status: 'stopped', 
                isPlaying: false,
                currentUrl: ''
            });
        
        logger.info('âœ… Stopped');
    } catch (error) {
        logger.error({ error }, 'Stop failed');
    }
}

async function pause() {
    try {
        logger.info('â¸ï¸ Pausing music...');
        await execAsync('pkill -STOP mpv');
        isPaused = true;
        isPlaying = false;
        
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ 
                status: 'paused', 
                isPlaying: false 
            });
        
        logger.info('âœ… Paused');
    } catch (error) {
        logger.error({ error }, 'Pause failed');
    }
}

async function resume() {
    try {
        logger.info('â–¶ï¸ Resuming music...');
        await execAsync('pkill -CONT mpv');
        isPaused = false;
        isPlaying = true;
        
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ 
                status: 'playing', 
                isPlaying: true,
                currentUrl: currentStreamUrl 
            });
        
        await updateDeviceHeartbeat(firestore, DEVICE_ID, true, currentStreamUrl || '');
        
        logger.info('âœ… Resumed');
    } catch (error) {
        logger.error({ error }, 'Resume failed');
    }
}

async function setVolume(volumePercent) {
    try {
        logger.info({ requested: volumePercent }, 'ðŸ”Š Setting volume...');
        currentVolume = Math.max(0, Math.min(100, volumePercent));
        const minVol = -10239;
        const maxVol = 400;
        const volumeRaw = Math.round(minVol + (currentVolume / 100) * (maxVol - minVol));
        await execAsync(`amixer set PCM -- ${volumeRaw}`);
        
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ volume: currentVolume });
        
        logger.info({ volume: currentVolume }, 'âœ… Volume set');
    } catch (error) {
        logger.error({ error }, 'Volume failed');
    }
}

// Command listener
const commandsRef = firestore.collection('config').doc('commands').collection('list');
commandsRef.where('deviceId', '==', DEVICE_ID).onSnapshot(async (snapshot) => {
    for (const change of snapshot.docChanges()) {
        if (change.type === 'added') {
            const cmd = change.doc.data();
            if (cmd.processed) continue;

            logger.info({ command: cmd.action, data: cmd }, 'ðŸ“¨ Command received');

            try {
                switch (cmd.action) {
                    case 'play':
                        if (isPaused) {
                            logger.info('Resuming from pause');
                            await resume();
                        } else {
                            logger.info('Starting new playback');
                            await play(cmd.streamUrl);
                        }
                        break;
                    case 'pause':
                        if (!isPaused && isPlaying) {
                            await pause();
                        } else {
                            logger.info('Already paused or not playing');
                        }
                        break;
                    case 'stop':
                        await stop();
                        break;
                    case 'volume':
                        await setVolume(cmd.volume || 100);
                        break;
                    case 'system_update':
                        logger.info('ðŸ”„ System update requested');
                        exec('bash /home/dietpi/radio-revive/rpi-agent/scripts/system-update.sh');
                        break;
                }

                await commandsRef.doc(change.doc.id).update({ processed: true });
                logger.info({ commandId: change.doc.id }, 'âœ… Command processed');
            } catch (error) {
                logger.error({ error, commandId: change.doc.id }, 'Command failed');
            }
        }
    }
});

// Heartbeat
setInterval(async () => {
    try {
        const status = isPaused ? 'paused' : isPlaying ? 'playing' : 'online';
        await updateDeviceHeartbeat(firestore, DEVICE_ID, isPlaying, currentStreamUrl || '');
        await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID)
            .update({ 
                status, 
                volume: currentVolume,
                isPlaying: isPlaying,
                isPaused: isPaused
            });
    } catch (error) {
        logger.error({ error }, 'Heartbeat failed');
    }
}, 5000);

// Init volume
setTimeout(async () => {
    await setVolume(100);
    logger.info('âœ… Volume initialized to 100%');
}, 5000);

// Auto-play
let autoPlayAttempts = 0;
const tryAutoPlay = async () => {
    try {
        autoPlayAttempts++;
        logger.info({ attempt: autoPlayAttempts }, 'ðŸŽµ Auto-play attempt');

        const deviceDoc = await firestore.collection('config').doc('devices').collection('list').doc(DEVICE_ID).get();
        if (!deviceDoc.exists) throw new Error('Device not found');

        const { groupId } = deviceDoc.data();
        if (!groupId) {
            logger.warn('No group assigned, skipping auto-play');
            return;
        }

        const groupDoc = await firestore.collection('config').doc('groups').collection('list').doc(groupId).get();
        if (!groupDoc.exists) throw new Error('Group not found');

        const { streamUrl } = groupDoc.data();
        if (streamUrl && !isPlaying && !isPaused) {
            logger.info({ url: streamUrl, groupId }, 'ðŸŽµ Auto-starting music');
            await play(streamUrl);
            logger.info('âœ… Auto-play successful!');
        } else {
            logger.info({ isPlaying, isPaused }, 'Skipping auto-play - already playing or paused');
        }
    } catch (error) {
        logger.error({ error: error.message, attempt: autoPlayAttempts }, 'Auto-play failed');
        if (autoPlayAttempts < 10) {
            const delay = Math.min(5000 * autoPlayAttempts, 30000);
            logger.info({ delay, nextAttempt: autoPlayAttempts + 1 }, 'Retrying auto-play...');
            setTimeout(tryAutoPlay, delay);
        } else {
            logger.error('âŒ Auto-play failed after max attempts');
        }
    }
};

setTimeout(tryAutoPlay, 10000);

logger.info('âœ… Agent initialized and ready');
